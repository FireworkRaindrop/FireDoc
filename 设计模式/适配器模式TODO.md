## 定义
适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

适配器模式也分两种，即**类适配器模式**和**对象适配器模式**

类适配器模式：使用继承（使得被适配对象类的函数在适配器类中也有，使得适配器类出现一些奇怪的接口）
对象适配器模式：使用代理（被适配对象的方法不会暴露出来，更加灵活，实用）

在实际的开发中Adapter通常应用于进行不兼容的类型转换的场景，还有一种就是输入有无数种情况，但是输出类型是统一的，我们可以通过Adapter返回一个统一的输出，而具体的输入留给用户处理，内部只需要知道输出的是符合我们要求的类型即可。例如ListView的Adapter，用户的Item View各式各样，但最终都是属于View类型，ListView只需要知道getView返回的是一个View即可，具体是什么View类型不需要ListView关心。

## 使用场景
（1）系统需要使用现有的类，而此类的接口不符合系统的需要，即接口不兼容。

（2）想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。

（3）需要一个统一的输出接口，而输入端的类型不可预知。


## Android源码中的适配器模式
##### ListView
ListView等集合控件通过Adapter来获取Item View的数量，布局，数据等，这里最重要的就是getView函数，这个函数返回一个View类型的对象，也就是Item View。由于它返回的是一个View抽象，而千变万化的UI视图都是View的子类，通过依赖抽象这个简单的原则和Adapter模式就将Item View的变化隔离开了，保证了AbsListView类族的高度可定制化。在获取了View之后，将这些View通过特定的布局方式设置到对应的位置上，再加上Item View的复用机制，整个ListView就运转起来了。

当然这里的Adapter并不是经典的适配器模式，似乎更像抽象工厂模式，getView，getItem等对应工厂中构建对象的函数，具体的抽象工厂类来构建具体的View，Item对象。


##### RecyclerView

将布局通过组合的形式交由LayoutManager实现，将布局这个职责分离开来，使得一个RecyclerView与不同的LayoutManager搭配就能做成各种布局效果，这也是用组合代替继承的优秀案例。

在RecyclerView中没有了getView函数，取而代之的是onBindViewHolder和onCreateViewHolder，这两个过程其实是将getView函数分解开来，使得加载视图和绑定数据分离开来。在RecyclerView中的操作单位也不再是View而是ViewHolder，对于ItemView的操作都从这个ViewHolder对象进行。通过onBindViewHolder和onCreateViewHolder两个函数，Android屏蔽了对Item view缓存的手动判断，将这部分逻辑封装在RecyclerView中，这样就不需要像ListView中的Adapter的getView函数那样对convertView进行判空等操作，简化了逻辑，隐藏了具体的实现。


## 实战
P398

通过复用ListAdapter实现圆形菜单控件，将界面分离出去,并且与现有的ListView，GridView等组件兼容。

## 小结
- 优点:
1. 更好的复用性

系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用

2. 更好的扩展性

在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。

- 缺点

过多地使用适配器，会让系统非常零乱，不易整体把握。例如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果出现太多这种情况，无异于一场灾难。因此，如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。
