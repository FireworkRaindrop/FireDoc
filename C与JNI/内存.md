## C

#####  alloca
在栈上分配了size大小的内存，因此使用此函数分配的内存不用再担心内存释放的情况了。但是使用此函数需要注意的是：在函数内部使用此函数分配的内存随着函数的终结不复存在，因此不能将此函数分配的内存供函数外部使用。

##### malloc

```
void* malloc(size_t byte_count)
```

malloc函数为长度size的对象分配内存，并返回指向分配区域的指针；若无法满足要求，则返回NULL。该函数不对分配的内存区域进行初始化。
malloc分配的内存是位于堆中的,并且没有
初始化内存的内容,因此基本上malloc之后,调用函数memset来初始化这部分的内存空间.

在堆上分配一个size byte大小的内存。它分配的单原完全按字节大小计算，因此如此分配N个单原的student_t，那么要这样实现：

```
(stdent_t *)malloc(N * sizeof (student_t));
```


#####  calloc

```
void* calloc(size_t item_count, size_t item_size)
```
calloc函数为由item_count个长度为item_size的对象组成的数组分配堆内存，并返回指向分配区域的指针；若无法满足要求，则返回NULL。分配 成功后 ，空间初始化为0


##### free
当程序运行过程中malloc了,但是没有free的话,会造成内存泄漏.一部分的内存没有被使用,但是由于没有free,因此系统认为这部分内存还在使用,造成不断的向系统申请内存,是的系统可用内存不断减少.但是,内存泄漏仅仅指程序在运行时,程序退出时,OS将回收所有的资源
##### realloc
该函数用于更改已经配置的内存空间，它同样是从堆中分配内存的。当程序需要扩大一块内存空间时，realloc 函数试图直接从堆上当前内存段后面的字节中获得更多的内存空间，即它将首先判断当前的指针是否有足够的连续存储空间，如果有，则扩大 ptr 指向的地址，并且将 ptr 返回（返回原指针）；如果当前内存段后面的空闲字节不够，那么将先按照 size 指定的大小分配空间（使用堆上第一个能够满足这一要求的内存块），并将原有数据从头到尾拷贝到新分配的内存区域，然后释放原来 ptr 所指内存区域，同时返回新分配的内存区域的首地址，即重新分配存储器块的地址。

需要注意的是，参数 ptr 为指向先前由 malloc、calloc 与 realloc 函数所返回的内存指针，而参数 size 为新分配的内存大小，其值可比原内存大或小。其中：

- 如果 size 值比原分配的内存空间小，内存内容不会改变（即新内存保持原内存的内容），且返回的指针为原来内存的首地址（即 ptr）。
- 如果 size 值比原分配的内存空间大，则 realloc 不一定会返回原来的指针，原内存的内容保持不变，但新多出的内存则设为初始值。

最后，如果内存分配成功，则返回首地址；如果内存分配失败，则返回 NULL。

##### aligned_alloc

```
void * aligned_alloc (size_t alignment,size_t size);
```

该函数属于 C11 标准提供的新函数，用于边界对齐的动态内存分配。该函数按照参数 alignment 规定的对齐方式为对象进行动态存储分配 size 个 size_t 类型的存储单元。如果内存分配成功，则返回首地址；否则内存分配失败，则返回 NULL。

相对于 malloc 函数，aligned_alloc 函数保证了返回的地址是能对齐的，同时也要求 size 参数是 alignment 参数的整数倍。从表面上看，函数 calloc 相对 malloc 更接近 aligned_alloc，但 calloc 函数比 aligned_alloc 函数多了一个动作，那就是会将内存内容初始化为 0。

##### sbrk
sbrk函数用来向os申请数据段，供malloc，calloc及realloc申请使用。


## 注意点
##### 强转
如 malloc、realloc、calloc、alloca 与 aligned_alloc 函数的返回都是“void*”类型。但需要特别注意的是，在使用这些内存管理函数进行内存分配时，必须将返回类型“void*”强制转换为指向被分配类型的指针

```
    char *p = (char *)malloc(10 * sizeof(char));
```
当然，为了能够简单调用，也可以将 malloc 函数使用 define 定义成如下形式：

```
    #define MALLOC(type) ((type *)malloc(sizeof(type)))
    /*或者*/
    #define MALLOC(number,type) ((type *)malloc((number) * sizeof(type)))
```
现在，调用就简单多了，如下面的代码所示：

```
    char *p = MALLOC(char);
    /*或者*/
    char *p = MALLOC(10, char);
```



##### 判空
 在调用malloc、realloc、calloc与 aligned_alloc这些内存分配函数时，必须进行返回值检查，以便能够及时得到内存分配是否成功与失败（如果分配失败则返回 NULL 指针），这样也可以避免因为内存分配错误而导致的不可预知和意外程序行为发生，如下面的示例代码所示：

```
    char *p = (char *)malloc(100);
    if (p == NULL)
    {
        /*处理内存分配错误，并返回错误状态*/
        return -1;
    }
```
##### 确保指针指向一块合法的内存
在 C 语言中，只要是指针变量，那么在使用它之前必须确保该指针变量的值是一个有效的值，它能够指向一块合法的内存，并从根本上避免未分配内存或者内存分配不足的情况发生。

```
    struct phonelist
    {
        int number;
        char *name;
        char *tel;
    }list,*plist;
    int main(void)
    {
        list.number = 1;
        strcpy(list.name, "Abby");
        strcpy(list.tel, "13511111111");
        /*...*/
        return 0;
    }
```
上面的代码片段，在定义结构体变量 list 时，并未给结构体 phonelist 内部的指针变量成员“char*name”与“char*tel”分配内存。这时候的指针变量成员“char*name”与“char*tel”并没有指向一个合法的地址，从而导致其内部存储的将是一些未知的乱码。

因此，在调用 strcpy 函数时，如“strcpy(list.name,"Abby")”语句会将字符串"Abby"向未知的乱码所指的内存上拷贝，而这块内存 name 指针根本就无权访问，从而导致程序出错。

既然没有给指针变量成员“char*name”与“char*tel”分配内存，那么解决的办法就是为指针变量成员分配内存，使其指向一个合法的地址，如下面的示例代码所示： 

```
    list.name = (char*)malloc(20*sizeof(char));
    strcpy(list.name, "Abby");
    list.tel = (char*)malloc(20*sizeof(char));
    strcpy(list.tel, "13511111111");
```
##### 确保为对象分配足够的内存空间

对于上面的结构体指针变量 plist 的内存分配语句：
```
plist = (struct phonelist*)malloc(sizeof(struct phonelist));
```
对于 malloc、calloc、realloc 与 aligned_alloc 内存分配函数中长度参数的大小，必须保证有足够的范围来表示对象要存储的大小。如果长度参数不正确或者可能被攻击者所操纵，将可能会出现缓冲区溢出。与此同时，不正确的长度参数、不充分的范围检查、整数溢出或截断都会导致分配长度不足的缓冲区。因此，一定要确保内存分配函数的长度参数能够合法地分配足够数量的内存。


##### 禁止执行零长度的内存分配
根据 C99 规定，如果在程序中试图调用 malloc、calloc 与 realloc 等系列内存分配函数分配长度为 0 的内存，那么其行为将是由具体编译器所定义的（如可能返回一个 null 指针，又或者是长度为非零的值等），从而导致产生不可预料的结果。

为了保证不会将 0 作为长度参数值传给 malloc、calloc 与 realloc 等系列内存分配函数，应该对这些内存分配函数的长度参数进行合法性检查，以保证它的合法取值范围。

```
    size_t len;
    /*初始化len变量*/
    if (len == 0)
    {
        /* 处理长度为0的错误 */
    }
    int *p = (int *)malloc(len);
    if (p == NULL)
    {
        /*...*/
    }
    /*...*/
```
##### 避免大型的堆栈分配
C99 标准引入了对变长数组的支持，如果变长数组的长度传入未进行任何检查和处理，那么将很容易被攻击者用来实施攻击，如常见的 DOS 攻击。

```
    int CopyFile(FILE *src, FILE *dst, size_t bufsize)
    {
        char buf[bufsize];
        while (fgets(buf, bufsize, src))
        {
                if （fputs(buf, dst) == EOF)
                {
                        /*...*/
                }
        }
        /*...*/
        return 0;
    }
```
在上面的示例代码中，数组“char buf[bufsize]”的长度将根据 CopyFile 函数的 bufsize 参数来决定，这显然不符合要求的。对于这种情况，可以通过一个 malloc 调用来替换掉这个变长数组。与此同时，如果 malloc 函数内存分配失败，还可以对返回值进行检查，从而防止程序异常终止等情况发生。如下面的示例代码所示： 

```
    int CopyFile(FILE *src, FILE *dst, size_t bufsize)
    {
        if (bufsize == 0)
        {
            /*...*/
        }
        char *buf = (char *)malloc(bufsize);
        if (buf == NULL)
        {
            /*...*/
        }
        while (fgets(buf, bufsize, src))
        {
            if (fputs(buf, dst) == EOF)
            {
                /*...*/
            }
        }
        /* ... */
        free(buf);
        buf = NULL;
        return 0;
    }
```
##### 避免内存分配成功，但并未初始化
在通常情况下，导致这种错误的主要原因有两个：

    没有初始化的观念。
    误以为内存的默认初值全部为零，从而导致引用初值错误（如数组）。


其实，内存的默认初值究竟是什么并没有统一的标准。如 malloc 函数分配得到的内存空间就是未初始化的，而它所分配的内存空间里可能包含出乎意料的值。因此，一般在使用该内存空间时，就需要调用函数 memset 来将其初始化为全 0。如下面的示例代码所示： 

## C++

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

- 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

- 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

- 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

- 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。

### 堆和栈的区别

碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题

生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

分配效率：堆的效率比栈要低得多

堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。



### new/delete

```
int *p1 = (int *)malloc(sizeof(int) * length);

int *p2 = new int[length];
```
new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。