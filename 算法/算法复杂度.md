## 概念
算法复杂度是指算法在编写成可执行程序后，运行时所需要的资源，资源包括时间资源和内存资源。

### 时间复杂度
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化

（1）在较复杂的算法中，进行精确分析是非常复杂的；

（2）一般来说，我们并不关心T(n)的精确度量，而只是关心其量级。

T (n) = O(f (n)) 表示存在一个常数C，当n趋于正无穷大时，总有T (n) ≤ C * f(n)，其意义是T(n)在n趋于正无穷大时跟f(n)基本接近，因此完全可以用f(n)来表示T(n)。

O(f (n))通常取执行次数中最高次方或最大指数部分的项。例如：

（1）阵列元素相加为2n+3 = O(n)

（2）矩阵相加为2n^2+2n+1 = O(n^2)

（3）矩阵相乘为2n^3+4n^2+2n+2 = O(n^3)

##### 常见的时间复杂度量有：

（1）O(1)：常量阶，运行时间为常量

（2）O(logn)：对数阶，如二分搜索算法

（3）O(n)：线性阶，如n个数内找最大值

（4）O(nlogn)：对数阶，如快速排序算法

（5）O(n^2)：平方阶，如选择排序，冒泡排序

（6）O(n^3)：立方阶，如两个n阶矩阵的乘法运算

（7）O(2^n)：指数阶，如n个元素集合的所有子集的算法

（8）O(n!)：阶乘阶，如n个元素全部排列的算法

常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜…＜Ο(2^n)＜Ο(n!)

我们应该尽可能选用多项式阶O(n^k)的算法，而不希望用指数阶的算法。

##### 对数阶

```
int count = 1;

while (count < n)

{

count = count * 2; /* 时间复杂度为O(1)的程序步骤序列 */

}
```


由于每次count乘以2之后，就距离n更近了一分。

也就是说，有多少个2相乘后大于n，则会退出循环。

由2x=n得到x=log2n。所以这个循环的时间复杂度为O(logn)。


### 评估算法时间复杂度的具体步骤是：

(1)找出算法中的基本语句；

算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体。

(2)计算基本语句的执行次数的数量级；

只需计算基本语句执行次数的数量级，这就意味着只要保证基本语句执行次数的函数中的最高次幂正确即可，可以忽略所有低次幂和最高次幂的系数。这样能够简化算法分析，并且使注意力集中在最重要的一点上：增长率。

(3)用大Ο记号表示算法的时间性能。

将基本语句执行次数的数量级放入大Ο记号中。


##### 在计算算法时间复杂度时有以下几个简单的程序分析法则:

(1).对于一些简单的输入输出语句或赋值语句,近似认为需要O(1)时间

(2).对于顺序结构,需要依次执行一系列语句所用的时间可采用大O下"求和法则"

求和法则:是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1(n)+T2(n)=O(max(f(n), g(n)))

特别地,若T1(m)=O(f(m)), T2(n)=O(g(n)),则 T1(m)+T2(n)=O(f(m) + g(n))

(3).对于选择结构,如if语句,它的主要时间耗费是在执行then字句或else字句所用的时间,需注意的是检验条件也需要O(1)时间

(4).对于循环结构,循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用大O下"乘法法则"

乘法法则: 是指若算法的2个部分时间复杂度分别为 T1(n)=O(f(n))和 T2(n)=O(g(n)),则 T1*T2=O(f(n)*g(n))

(5).对于复杂的算法,可以将它分成几个容易估算的部分,然后利用求和法则和乘法法则技术整个算法的时间复杂度

另外还有以下2个运算法则:

(1) 若g(n)=O(f(n)),则O(f(n))+ O(g(n))= O(f(n))；

(2) O(Cf(n)) = O(f(n)),其中C是一个正常数

### 空间复杂度

与时间复杂度类似，空间复杂度是指算法在计算机内执行时所需存储空间的度量。记作:

```
S(n)=O(f(n))
```

算法执行期间所需要的存储空间包括3个部分：
- 算法程序所占的空间；
- 输入的初始数据所占的存储空间；
- 算法执行过程中所需要的额外空间。