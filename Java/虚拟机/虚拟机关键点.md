## 1 走近Java
- p5:java发展史
- p9:java虚拟机发展史
- p10:Exact VM因使用准确式内存管理而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。
- p22:自己编译JDK

##### 2 Java内存区域与内存溢出异常
- P38:JAVA虚拟机运行时数据区划分
- p39:**程序计数器**：（线程私有）当前线程所执行字节码的行号指示器
- p39:**java虚拟机栈**：（线程私有）描述的是java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，执行完成即出栈。
- p40:**本地方法栈**：（线程私有）为虚拟机执行native方法服务。HotSpots虚拟机将本地方法栈和虚拟机栈合二为一
- p41：**java堆**：（线程共享）在虚拟机启动时创建，用于存放对象实例与数组
- p41：**方法区**：（线程共享）用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。HotSpot使用永久代来实现方法区，方便垃圾收集器管理。官方欲逐渐放弃永久代改为用Native Memory来实现方法区。JDK1.7中已经把原本放在永久代的常量池字符串移出。
- p42:运行时常量池（方法区的一部分）用于存放类加载后编译期生成的各种字面量与符号引用
- p43:直接内存（如JDK1.4新加入的NIO类）
- p44:对象创建的内存分配：指针碰撞，空闲列表(由采用的垃圾收集器是否带有压缩整理功能决定)
- p45:对象创建的并发处理:CAS+失败重试与本地线程分配缓冲(TLAB)
- p47:对象的内存布局：对象头(Header)，实例数据(Instance Data)，对齐填充(Padding)
- p47:HotSpot中对象头包括两部分信息：自身的运行时数据（Mark Word）与类型指针（通过这个来确定这个对象是哪个类的实例）如果是数组对象那还必须有一块用于记录数组长度
- p48：实例数据：记录父类和子类定义的字段内容。分配策略：相同宽度的字段被分配到一起，父类变量会在子类之前，子类短变量也可能插入父类变量空隙之中
- p48:对其填充，不是必然存在的。HotSpot虚拟机的内存自动管理系统要求对象大小必须是8字节的整数倍。对象头正好是8字节的1倍或者2倍，所以当实例数据没有对齐时就需要填充。
- p48:对象的访问定位：句柄和直接指针两种
- p49:句柄访问好处是稳定的句柄地址，对象移动时reference不需要改，指针访问的好处是快，节约一次指针定位的开销。在HotSpot虚拟机中使用指针访问。
- p50:除了程序计数器外，虚拟机的另外几个运行时区域都有发生OOM的可能。
- p52:使用Eclipse Memory Analyzer对Dump出来的堆转储快照分析是否出现了内存泄漏还是内存溢出
- p53:HotSpot虚拟机中并不区分虚拟机栈和本地方法栈。
- p53:StackOverflowError:线程请求的栈深度大于虚拟机所允许的最大深度
- p53:OutOfMemoryError:虚拟机在拓展栈时无法申请到足够的内存空间
- p56:String.intern()在JDK1.6与1.7的区别
- p58:CGLib
- p59：反射使用Unsafe.allocateMemory();真正申请分配内存。

##### 3 垃圾收集器与内存分配策略
- p61:1960年诞生于MIT的Lisp语言是第一门真正使用内存动态分配与垃圾收集技术的语言。
- p61:程序计数器，虚拟机栈，本地方法栈跟随线程而生死具有确定性，所以回收不需要考虑这三个区域，而需要考虑java堆和方法区两部分。
- p62:主流的java虚拟机中没有选用引用计数法来管理内存，主要原因是他很难解决对象间循环引用的问题。
- p64:主流商用语言（java,C#,Lisp等）的主流实现中都是通过**可达性分析**来判断对象是否存活的。当一个对象到GC Roots没有任何引用链时，即认为是可以回收的。
- p64:可作为**GC Roots**的对象：1.虚拟机栈(栈帧中的本地变量表)中引用的对象。2.方法区中类静态属性引用的变量。3，方法区中常量引用的对象。4.本地方法栈中JNI引用的对象。
- p65:JDK1.2之后将引用分为强引用，软引用，弱引用，虚引用4种。
- p66:**对象死亡**需要经历两次标记的过程。如果对象在可达性分析后发现没有与GC Roots相连接的引用链，那他会第一次被标记，并进行一次筛选，筛选条件是对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，则视为没有必要执行。如果对象呗判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫F-Queue的队列之中，并在稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行（只是触发执行，不承诺等待执行结束）。finalize()方法是对象逃脱死亡的最后一次机会。稍后GC将会对F-Queue中的对象进行第二次小规模的标记，如果对象此时与任何引用链上的对象建立联系即可在第二次标记时移出“即将回收”的集合。如果对象这时候还没有逃脱那么就会被回收。
- p68：方法区（HotSpot中的永久代）垃圾收集主要回收两部分：废弃常量和无用的类。
- p68:判定无用的类的三个条件：1.该类所有的实例都已经被回收，也就是JAVA堆中不存在该类的任何实例。2.加载该类的ClassLoader已经被回收。3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。虚拟机可以对满足上述3个条件的无用类进行回收。
- p69:标记-清除算法：（最基础的收集算法）分为标记和清除两个阶段。缺点:1.标记与清除效率都不高。2.产生不连续的内存碎片。

##### 4

##### 5 

##### 6
- p186:this关键字实现方式及表现
- P189:LineNumberTable,LocalVariableTable
- p194:Signature属性与泛型的关系
- P202:类型转换指令

##### 7
- p210:有且只有5种情况会对类进行初始化
- p214:接口初始化与类的不同
- p214:从不同途径去加载Class文件出现的不同技术
- p215:数组类加载的不同，java.lang.Class类的特殊
- p225:<clinit>()方法

##### 8
- p241:为什么对象没有被回收以及手动置null的意义
- p242:类变量有系统初始值，局部变量不会自动赋初始值
- p245:哪些是编译期可知，运行期不可变的方法
- p249:重载方法匹配优先级
- p254:方法重写的本质
- p256:目前java是静态多分派，动态单分派的语言
- p263:Reflection与MethodHandle机制的区别
- p268:java中如何调用祖类方法


##### 9
- p283：动态代理的底层实现


###### 10


##### 11
- p335：方法调用计数器的半衰周期，回边计数器
- p342:输出伪汇编结果
- p346:HotSpot虚拟机在即时编译器中采用的优化技术
- p348:为什么方法内联放在优化第一步
- p354:如何解决虚方法的内联

##### 12
- p363:线程，主内存，工作内存三者的交互关系
- p364:主内存与工作线程的8种原子操作定义
- p370:jdk1.5之后volatile屏蔽指令重排序及原因
- p373:原子性，可见性，有序性
- p376:java内存模型中的先行发生规则(hanpens-before)
- p381：java线程的实现

##### 13
- p386:不可变，绝对线程安全，相对线程安全，线程兼容与线程对立
- p391:互斥同步，synchronized与ReentrantLock（悲观）
- p393:非阻塞同步（乐观）
- p394:CAS（Compare-and-Swap）操作,AtomicInteger
- p396：可重入代码
- p398：自旋锁与自适应自旋锁
- p400:对象头Mark Word与轻量级锁和偏向锁

