## 2 Java内存区域与内存溢出异常
### 2.2运行时数据区域
- P38:JAVA虚拟机运行时数据区划分

##### 程序计数器
- p39:**程序计数器**：（线程私有）当前线程所执行字节码的行号指示器

##### java虚拟机栈
- p39:**java虚拟机栈**：（线程私有）描述的是java方法执行的内存模型，每个方法执行的时候都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出入口等信息，执行完成即出栈。

##### 本地方法栈
- p40:**本地方法栈**：（线程私有）为虚拟机执行native方法服务。HotSpots虚拟机将本地方法栈和虚拟机栈合二为一

##### java堆
- p41：**java堆**：（线程共享）在虚拟机启动时创建，用于存放对象实例与数组

##### 方法区
- p41：**方法区**：（线程共享）用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。HotSpot使用永久代来实现方法区，方便垃圾收集器管理。官方欲逐渐放弃永久代改为用Native Memory来实现方法区。JDK1.7中已经把原本放在永久代的常量池字符串移出。

##### 运行时常量池
- p42:运行时常量池（方法区的一部分）用于存放类加载后编译期生成的各种字面量与符号引用

##### 直接内存
- p43:直接内存（如JDK1.4新加入的NIO类）

### 2.3HotSpot虚拟机对象探秘
##### 对象的创建
- p44:对象创建的内存分配：指针碰撞，空闲列表(由采用的垃圾收集器是否带有压缩整理功能决定)
- p45:对象创建的并发处理:CAS+失败重试与本地线程分配缓冲(TLAB)

##### 对象的内存布局
- p47:对象的内存布局：对象头(Header)，实例数据(Instance Data)，对齐填充(Padding)
- p47:HotSpot中对象头包括两部分信息：自身的运行时数据（Mark Word）与类型指针（通过这个来确定这个对象是哪个类的实例）如果是数组对象那还必须有一块用于记录数组长度
- p48：实例数据：记录父类和子类定义的字段内容。分配策略：相同宽度的字段被分配到一起，父类变量会在子类之前，子类短变量也可能插入父类变量空隙之中
- p48:对其填充，不是必然存在的。HotSpot虚拟机的内存自动管理系统要求对象大小必须是8字节的整数倍。对象头正好是8字节的1倍或者2倍，所以当实例数据没有对齐时就需要填充。

##### 对象的访问定位
- p48:对象的访问定位：句柄和直接指针两种
- p49:句柄访问好处是稳定的句柄地址，对象移动时reference不需要改，指针访问的好处是快，节约一次指针定位的开销。在HotSpot虚拟机中使用指针访问。

##### 实战：OutOfMemoryError异常
- p50:除了程序计数器外，虚拟机的另外几个运行时区域都有发生OOM的可能。
- p52:使用Eclipse Memory Analyzer对Dump出来的堆转储快照分析是否出现了内存泄漏还是内存溢出
- p53:HotSpot虚拟机中并不区分虚拟机栈和本地方法栈。
- p53:StackOverflowError:线程请求的栈深度大于虚拟机所允许的最大深度
- p53:OutOfMemoryError:虚拟机在拓展栈时无法申请到足够的内存空间
- p56:String.intern()在JDK1.6与1.7的区别
- p58:CGLib
- p59：反射使用Unsafe.allocateMemory();真正申请分配内存。