## 线程安全
《Java Concurrency In Practice》的作者Brian Goetz定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

要求线程安全的代码都必须具备一个特性：代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。

### Java语言中的线程安全
按照线程安全的“安全程度”由强至弱来排序，我们可以把Java语言中各种操作共享的数据分为以下五类：不可变，绝对线程安全，相对线程安全，线程兼容和线程对立。

##### 不可变
在Java语言中（特指JDK1.5之后，及Java内存模型被修正之后的Java语言），不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。

“不可变”带来的安全性是最简单和最纯粹的。

- 如果共享数据是一个基本数据类型：在定义时使用final关键字修饰它就可以保证它是不可变的。
- 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行。

比如java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring(),replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。


保证对象行为不影响自己状态的途径有很多种，其中最简单的就是把对象中带有状态的变量都声明为final，这样在构造函数结束之后，他就是不可变的。

如java.lang.Integer构造函数，通过将内部状态变量value定义为final来保障状态不可变。以及枚举类，以及java.lang.Number的部分子类，如Long和Double等数值包装类型，BigInteger和BigDecimal等大数据类型；

但是同为java.lang.Number的子类型的原子类AtomicInteger和AtomicLong则并非是不可变的。

##### 绝对线程安全
绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大。在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。

如：java.util.Vector是一个线程安全的容器，因为它的add(),get(),size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，尽管它所有的方法都被修饰为同步，也不意味着调用它的时候永远都不需要同步手段了。

在多线程的环境下如果不在方法调用端做额外的同步措施的话，使用Vector仍然是不安全的。

##### 相对线程安全
相对的线程安全就是我们通常意义上讲的线程安全，它保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。

在Java中大部分的安全类都属于这种类型，例如Vector,HashTable,Collections的synchronizedCollection()方法包装的集合等。

##### 线程兼容
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平时说一个类不是线程安全的，绝大多数时候指的是这种情况。

Java API中大部分类都是线程兼容的，如ArrayList和HashMap等。

##### 线程对立
线程对立指的是无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。

一个线程对立的例子是Thread类的suspend()和resume()方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都存在死锁风险的，如果suspend()中断的线程就是 即将要执行resume()的那个线程，那就肯定要产生死锁了。（这两个方法已经被jdk标为废弃了）

常见的线程对立的操作还有System.setIn()和System.setOut()和System.runFinalizersOnExit()等。

### 线程安全的实现方法

##### 互斥同步
互斥同步指在多个线程并发访问共享数据时，保证共享数据在同一时刻只被（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段。临界区(Critical Section)，互斥量(Mutex)和信号量(Semaphore)都是主要的互斥实现方式。互斥是因，同步是果；互斥是方法，同步是目的。

在Java中，最基本的互斥同步手段就是synchronize关键字，synchronize关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexist这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果java程序中synchronize明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronize修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取锁对象失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

- synchronize同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。
- 同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。

Java线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。所以synchronize是java语言中一个重量级(Heavyweight)的操作。


除了synchronize之外，我们还可以使用java.util.concurrent包中的重入锁(ReentrantLock)来实现同步。两者都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面上的互斥锁。

ReentrantLock相比synchronize增加了一些高级功能，主要有以下3项：等待可中断，可实现公平锁，以及锁可以绑定多个条件。

- 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
- 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronize中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
- 锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronize中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无需这样做，只需要多次调用newCondition()方法即可。


虚拟机在未来的性能改进中肯定也会更加偏向原生的synchronize，所以还是提倡在synchronize能实现需求的情况下，优先考虑使用synchronize来进行同步。

##### 非阻塞同步
互斥同步最主要的问题就是进行线程阻塞和唤醒带来的性能问题，因此这种同步也称为**阻塞同步**(Blocking Synchronization);从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。随着指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为**非阻塞同步**


###### 为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？
因为我们需要操作和冲突检测这两个步骤具备原子性。靠什么来保证呢？如果这里再采用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：
- 测试并设置(Test-and-Set)
- 获取并增加(Fetch-and-Increment)
- 交换(Swap)
- 比较并交换(Compare-and-Swap,下文称CAS)
- 加载链接、条件存储(Load-Linked/Store-Conditional,下文称LL/SC)

###### CAS
CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示），旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。

在JDK1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。

由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如J.U.C包里面的整数原子类，其中的comapreAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。

尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在一个叫“**ABA**”的漏洞：一个变量V初次读取的时候为A只，期间变为了B，后来又变为了A，在准备赋值的时候检查到它仍然是A值，那CAS操作就会误认为它从来没有被改变过。J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。

如果要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。
##### 无同步方案
要保证线程安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。

###### 可重入代码
这种代码也叫**纯代码**，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入，不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。

###### 线程本地存储
如果一段代码中所需要的数据必须与其他代码共享，并且我们能保证这些共享数据的代码在同一个线程中执行，那么我们就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程直接不出现数据争用的问题。

**ThreadLocal**
可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，利用这个值就可以在线程K-V值对中找回对应的本地线程变量。

采用了开放地址法

## 锁优化
高并发是从JDK1.5到JDK1.6的一个重要改进，如适应性自旋，锁消除，锁粗化，轻量级锁和偏向锁等。

##### 自旋锁与自适应自旋
互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果一个物理机上有一个以上的的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋锁在JDK1.4.2中就已经引入了，只不过是默认关闭的，在JDK1.6中就已经是默认开启了。

自旋锁不能替代阻塞，且不说对处理器的要求，自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋等待的线程只会白白消耗处理器资源，带来性能上的浪费。

在JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也会很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获得这个锁时将可能省略掉自旋过程。


##### 锁消除
锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步枷锁自然就无须进行。

##### 锁粗化
如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

##### 轻量级锁
轻量级锁是JDK1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。

##### 偏向锁
偏向锁也是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。




