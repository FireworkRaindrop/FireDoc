# 算法分类
- **单向加密** ：通过对数据进行摘要计算生成密文，密文不可逆推还原。
  
  算法代表：Base64，MD5，SHA
- **双向加密** ：与单向加密相反，可以把密文逆推还原成明文
  - **对称加密**：使用同一密钥进行加密解密，速度快
  
    算法代表：DES，3DES，AES，IDEA，RC4，RC5
  - **非对称加密**：使用一组密钥对进行加密解密，密钥对分为公钥与私钥。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。速度慢。

   >   1、公钥加密体制用于保密性时，就是公钥加密，私钥解密。 因为公钥是可以公开了， 那么任何人都可以使用公钥对信息进行加密，但是只有持有私钥的人才能正确解密。这样就保证了信息的保密性，因为只有私钥持有者才能正确解密。
   
   >   2、公钥加密体制用于认证性时，比如数字签名，即私钥持有者对信息进行签名，验证者可以根据公开的公钥进行验证签名是否正确和有效，即实现了认证性，以及不可抵赖性。
  
    算法代表：RSA，DSA，Elgamal，背包算法，Rabin，D-H，ECC（椭圆曲线加密算法）。
    
# 单向加密
### Base64
base64不是安全领域下的加密解密算法,核心作用应该是简化存储或传输，主要用于转换二进 制数据为ASCII字符串格式

Base64只包含A—Z，a—z，0—9，+，/ 这64个字符（ 26个大写字母，26个小写字母，10个数字，1个+，一个 / 刚好64个字符）。
一个Base64字符仍然是8个bit位，但是有效部分只有右边的6个 bit，左边两个永远是0。

编码原理是将3个字节转换成4个字节
(3 X 8) = 24 = (4 X 6) 
先读入3个字节，每读一个字节，左移8位，再右移四次，每次6位，这样就有4个字节了。
这样还不能保证得到的字符都是可见字符，为了达到此目的，Base64制定了一个编码表，进行统一的转换。
码表的大小为2^6=64，这也是Base64名称的由来。
当剩下的字符数量不足3个字节时，则应使用0进行填充，相应的，输出字符则使用'='占位，因此编码后输出的文本末尾可能会出现1至2个'='。

Base64编码对照表：
![image](https://images2015.cnblogs.com/blog/1008733/201612/1008733-20161212133256964-2147283831.png)

编码例子：SLF->U0xG
![image](https://images2015.cnblogs.com/blog/1008733/201612/1008733-20161212133322729-1267197111.png)

### MD5(Message Digest Algorithm 5 )
MD5消息摘要算法，属Hash算法一类。MD5算法对输入任意长度的消息进行运行，产生一个128位的消息摘要

算法原理:

1、数据填充

对消息进行数据填充,填充方法为在消息后面进行填充，填充第一位为1，其余为0。，使消息的长度对512取模得448，设消息长度为X，即满足X mod 512=448。信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零

2、添加消息长度

在第一步结果之后再填充上原消息的长度，可用来进行的存储长度为64位。如果消息长度大于264，则只使用其低64位的值，即（消息长度 对 264取模）。

现在的信息的位长=N*512+448+64=(N+1）*512，即长度恰好是512的整数倍。

3、数据处理

装入标准的幻数：标准的幻数是(A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16)。如果在程序中定义应该是(A=0X67452301L，B=0XEFCDAB89L，C=0X98BADCFEL，D=0X10325476L)。

4个函数：

F(X,Y,Z)=(X & Y) | ((~X) & Z); 

G(X,Y,Z)=(X & Z) | (Y & (~Z));

H(X,Y,Z)=X ^ Y ^ Z; 

I(X,Y,Z)=Y ^ (X | (~Z));

把消息分以512位为一分组进行处理，每一个分组进行4轮变换，以上面所说4个常数为起始变量进行计算，重新输出4个变量，以这4个变量再进行下一分组的运算，如果已经是最后一个分组，则这4个变量为最后的结果，即MD5值。


## SHA（Secure Hash Algorithm）
SHA由美国标准与技术研究所（NIST）设计并于1993年发表，该版本称为SHA-0，由于很快被发现存在安全隐患，1995年发布了SHA-1。

　　2002年，NIST分别发布了SHA-256、SHA-384、SHA-512，这些算法统称SHA-2。2008年又新增了SHA-224。

　　由于SHA-1已经不太安全，目前SHA-2各版本已成为主流。
　　
　　
![image](https://images2015.cnblogs.com/blog/929265/201607/929265-20160701092331874-1851324775.png)


# 双向加密

## 对称加密
## DES（Data Encryption Standard，标准加密算法）
1997年数据加密标准DES正式公布，其分组长度为64比特，密钥长度为64比特,由于第
n*8(n=1,2,…8)是奇偶校验位，因此实际参与加密的长度为56位，密钥空间含有2^56
个密钥

DES全称为Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法，1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。需要注意的是，在某些文献中，作为算法的DES称为数据加密算法（Data Encryption Algorithm,DSA），已与作为标准的DES区分开来。

DES设计中使用了分组密码设计的两个原则：混淆（confusion）和扩散(diffusion)
，其目的是抗击敌手对密码系统的统计分析。混淆是使密文的统计特性与密钥的取值
之间的关系尽可能复杂化，以使密钥和明文以及密文之间的依赖性对密码分析者来说
是无法利用的。扩散的作用就是将每一位明文的影响尽可能迅速地作用到较多的输出
密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可
能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。

主要分为两步：
- 初始置换
其功能是把输入的 64 位数据块按位重新组合,并把输出分为 L0、R0 两部分，每部分各长 32 位，其置换规则为将输入的第 58 位换到第一位，第 50 位换到第 2 位 …… 依此类推,最后一位是原来的第 7 位。L0、R0 则是换位输出后的两部分，L0 是输出的左 32 位，R0 是右  32 位，例：设置换前的输入值为 D1 D2 D3 …… D64，则经过初始置换后的结果为：L0 = D58 D50 …… D8；R0 = D57 D49 …… D7

- 逆置换 
经过 16 次迭代运算后，得到 L16、R16，将此作为输入，进行逆置换，逆置换正好是初始置换的逆运算，由此即得到密文输出。

## 3DES（Triple Data Encryption Standard，三重标准加密算法）
3DES（即Triple DES）是DES向AES过渡的加密算法（1999年，NIST将3-DES指定为过渡的加密标准），加密算法，其具体实现如下：设Ek()和Dk()代表DES算法的加密和解密过程，K代表DES算法使用的密钥，M代表明文，C代表密文，这样：
- 3DES加密过程为：C=Ek3(Dk2(Ek1(M)))
- 3DES解密过程为：M=Dk1(EK2(Dk3(C)))

![image](https://images2015.cnblogs.com/blog/831650/201604/831650-20160422115520210-793628300.png)

在上图中3DES算法在对明文M进行加密时，采用了三次加密过程，其中第一次和第三次是采用DES的加密算法，第二次采用的则是解密算法，从而得到最终的密文C。这种加密过程为“加密-解密-加密”，所以又称为EDE（Encrypt-Decrypt-Encrypt）方案

K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位。

但是 不能有 k1 = k2 = k3，如果 k1 = k2 = k3 ，则退化为DES加密；

## AES（Advantaged Encryption Standard，高级加密算法）
AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：

原理可参考：https://blog.csdn.net/qq_28205153/article/details/55798628

## 填充格式

##### PKCS#5与PKCS#7

PKCS#5填充是PKCS#7填充的一个子集，在PKCS#7填充时BlockSize为8的时候，PKCS#5与PKCS#7填充是一样的， 在BlockSize不同时PKCS#5与PKCS#7填充是不同的，PKCS#5填充是将数据填充到8的倍数，填充后数据长度的计算公式是 定于元数据长度为x， 填充后的长度是 x + (8 - (x % 8)), 填充的数据是 8 - (x % 8)

PKCS#5：假设待加密数据长度为x，那么将会在后面padding的字节数目为8-(x%8)，每个padding的字节值是8-(x%8)。特别地，当待加密数据长度x恰好是8的整数倍，也是要在后面多增加8个字节，每个字节是0x08。如下：
```
待加密数据原长度为1字节：
0x41
填充后：
0x410x070x070x070x070x070x070x07

待加密数据原长度为7字节：
0x410x410x410x410x410x410x41
填充后：
0x410x410x410x410x410x410x410x01

......

待加密数据原长度为8字节：
0x410x410x410x410x410x410x410x41
填充后：
0x410x410x410x410x410x410x410x410x080x080x080x080x080x080x080x08
```


## 分组密码的模式

- ECB模式：Electronic CodeBook mode（电子密码本模式）
- CBC模式：Cipher Block Chaining mode（密码分组链接模式）
- CFB模式：Cipher FeedBack mode（密文反馈模式）
- OFB模式：Output FeedBack mode（输出反馈模式）
- CTR模式：CounTeR mode（计数器模式）

### 电子密码本模式(ECB)
将整个明文分成若干段相同的小段，然后对每一小段进行加密。

优：操作简单，易于实现；分组独立，易于并行；误差不会被传送。——简单，可并行，不传送误差。

缺：掩盖不了明文结构信息，难以抵抗统计分析攻击。——可对明文进行主动攻击。
 ![image](https://images0.cnblogs.com/blog/781316/201507/232139414591222.png)
 
### 密码分组链接模式(CBC)
先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。

优点：能掩盖明文结构信息，保证相同密文可得不同明文，所以不容易主动攻击，安全性好于ECB，适合传输长度长的报文，是SSL和IPSec的标准。
缺点：（1）不利于并行计算；（2）传递误差——前一个出错则后续全错；（3）第一个明文块需要与一个初始化向量IV进行抑或，初始化向量IV的选取比较复杂。

初始化IV的选取方式：固定IV，计数器IV，随机IV（只能得到伪随机数，用的最多），瞬时IV（难以得到瞬时值）

![image](https://images.cnblogs.com/cnblogs_com/happyhippy/2CBC.jpg)

### 密文反馈模式(CFB)
 优点：

1.隐藏了明文模式;

2.分组密码转化为流模式;

3.可以及时加密传送小于分组的数据;

缺点:

1.不利于并行计算;

2.误差传送：一个明文单元损坏影响多个单元;

3.唯一的IV;
![image](https://images0.cnblogs.com/blog/781316/201507/232139450061606.png)
### 输出反馈模式(OFB)
 优点:

1.隐藏了明文模式;

2.分组密码转化为流模式;

3.可以及时加密传送小于分组的数据;

缺点:

1.不利于并行计算;

2.对明文的主动攻击是可能的;

3.误差传送：一个明文单元损坏影响多个单元;
![image](http://images0.cnblogs.com/blog/781316/201507/232139460065433.png)
### 计数器模式(CTR)
完全的流模式。将瞬时值与计数器连接起来，然后对此进行加密产生密钥流的一个密钥块，再进行XOR操作 。

优点：不泄露明文；仅需实现加密函数；无需填充；可并行计算。

缺点：需要瞬时值IV，难以保证IV的唯一性。

#### salt盐度与用户密码加密机制
我们知道，如果直接对密码进行散列，那么黑客（统称那些有能力窃取用户数据并企图得到用户密码的人）可以对一个已知密码进行散列，然后通过对比散列值得到某用户的密码。换句话说，虽然黑客不能取得某特定用户的密码，但他可以知道使用特定密码的用户有哪些。

加Salt可以一定程度上解决这一问题。所谓加Salt，就是加点“佐料”。其基本想法是这样的——当用户首次提供密码时（通常是注册时），由系统自动往这个密码里撒一些“佐料”，然后再散列。而当用户登录时，系统为用户提供的代码撒上同样的“佐料”，然后散列，再比较散列值，已确定密码是否正确。

这里的“佐料”被称作“Salt值”，这个值是由系统随机生成的，并且只有系统知道。这样，即便两个用户使用了同一个密码，由于系统为它们生成的salt值不同，他们的散列值也是不同的。即便黑客可以通过自己的密码和自己生成的散列值来找具有特定密码的用户，但这个几率太小了（密码和salt值都得和黑客使用的一样才行）。

盐的长度不能过短，并且盐的产生应该是随机的

下面详细介绍一下加Salt散列的过程。介绍之前先强调一点，前面说过，验证密码时要使用和最初散列密码时使用“相同的”佐料。所以Salt值是要存放在数据库里的。（有时候，为了减轻开发压力，程序员会统一使用一个salt值（储存在某个地方），而不是每个用户都生成私有的salt值。）

用户注册时，

1）用户提供密码（以及其他用户信息）；
2）系统为用户生成Salt值；
3）系统将Salt值和用户密码连接到一起；
4）对连接后的值进行散列，得到Hash值；
5）将Hash值和Salt值分别放到数据库中。
![image](https://img-blog.csdn.net/20151123100949799?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

用户登录时，

1）用户提供用户名和密码；
2）系统通过用户名找到与之对应的Hash值和Salt值；
3）系统将Salt值和用户提供的密码连接到一起；
4）对连接后的值进行散列，得到Hash'（注意有个“撇”）；
5）比较Hash和Hash'是否相等，相等则表示密码正确，否则表示密码错误。
![image](https://img-blog.csdn.net/20151123100957324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)


登录方案例子：
![image](https://pic3.zhimg.com/80/4c4da94c77729b0bfc12eb0274ba0ec4_hd.jpg)

（为了应对暴力破解，我使用了加盐的慢哈希。慢哈希是指执行这个哈希函数非常慢，这样暴力破解需要枚举遍历所有可能结果时，就需要花上非常非常长的时间。比如：bcrypt 就是这样一个慢哈希函数：）

## 非对称加密
### RSA
1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法。

这种算法非常可靠，密钥越长，它就越难破解。根据已经披露的文献，目前被破解的最长RSA密钥是768个二进制位。也就是说，长度超过768位的密钥，还无法破解（至少没人公开宣布）。因此可以认为，1024位的RSA密钥基本安全，2048位的密钥极其安全。

RSA算法基于简单的数论事实：将两个大质数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。

##### 原理：
http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html

在RSA密码应用中，公钥KU是被公开的，即e和n的数值可以被第三方窃听者得到。破解RSA密码的问题就是从已知的e和n的数值（n等于pq），想法求出d的数值，这样就可以得到私钥来破解密文。从上文中的公式：d ≡e-1 (mod((p-1)(q-1)))或de≡1 (mod((p-1)(q-1))) 我们可以看出。密码破解的实质问题是：从Pq的数值，去求出(p-1)和(q-1)。换句话说，只要求出p和q的值，我们就能求出d的值而得到私钥。
　 　当p和q是一个大素数的时候，从它们的积pq去分解因子p和q，这是一个公认的数学难题。比如当pq大到1024位时，迄今为止还没有人能够利用任何计算工具去完成分解因子的任务。因此，RSA从提出到现在已近二十年，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。
　　然而，虽然RSA的安全性依赖于大数的因子分解，但并没有从理论上证明破译RSA的难度与大数分解难度等价。即RSA的重大缺陷是无法从理论上把握它的保密性能如何。
　　此外，RSA的缺点还有：A)产生密钥很麻烦，受到素数产生技术的限制，因而难以做到一次一密。B)分组长度太大，为保证安全性，n 至少也要 600 bits 以上，使运算代价很高，尤其是速度较慢，较对称密码算法慢几个数量级；且随着大数分解技术的发展，这个长度还在增加，不利于数据格式的标准化。因此，使用RSA只能加密少量数据，大量的数据加密还要靠对称密码算法。
　　
　　
##### java中使用

生成模数、公钥指数和私钥指数:
```
KeyPairGenerator generator = KeyPairGenerator.getInstance("RSA");
generator.initialize(1024);
KeyPair pair = generator.generateKeyPair();
RSAPrivateKey privateKey = (RSAPrivateKey) pair.getPrivate();
RSAPublicKey publicKey = (RSAPublicKey) pair.getPublic();
println("publicKey exponent:" + publicKey.getPublicExponent());
println("publicKey modules:" + publicKey.getModulus());
println("publicKey format:" + publicKey.getFormat());
println("---------------------华丽的分割线-------------------------");
println("privateKey exponent:" + privateKey.getPrivateExponent());
println("privateKey modules:" +  privateKey.getModulus());
println("privateKey format:" + privateKey.getFormat());
```
结果：

```
publicKey exponent:65537
publicKey modules:154471992999058139479994460025815654498183391593444870454838266974581244599191659985455957889064163942388409487313472074598227824609910604156744751985833898809065078785899074110993629452358669379496163284362583792866500058660069050752020922895749548342185553141417346777273482310707415185758164008066298773949
publicKey format:X.509
---------------------华丽的分割线-------------------------
privateKey exponent:24953766420205815381764520016071994967304996670579990593182061010725111564027070269710579156377653900210050677360692873548856950717077735724971492275722465522175892883197573916804276397143284954594245180776141869860033925480138858143033802945465036705957639063440190950861284456594945244826689811470380537909
privateKey modules:154471992999058139479994460025815654498183391593444870454838266974581244599191659985455957889064163942388409487313472074598227824609910604156744751985833898809065078785899074110993629452358669379496163284362583792866500058660069050752020922895749548342185553141417346777273482310707415185758164008066298773949
privateKey format:PKCS#8
```
加解密：

```
//公钥加密
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
BigInteger modulus = new BigInteger("154471992999058139479994460025815654498183391593444870454838266974581244599191659985455957889064163942388409487313472074598227824609910604156744751985833898809065078785899074110993629452358669379496163284362583792866500058660069050752020922895749548342185553141417346777273482310707415185758164008066298773949",10);
BigInteger publicExponent = new BigInteger("65537");
RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus,publicExponent);
PublicKey publicKey = keyFactory.generatePublic(rsaPublicKeySpec);
Cipher cipher = Cipher.getInstance("RSA");
cipher.init(Cipher.ENCRYPT_MODE,publicKey);
byte[]  encryptData = cipher.doFinal("Hello,RSA!".getBytes());
//私钥解密
BigInteger privateExponent = new BigInteger("24953766420205815381764520016071994967304996670579990593182061010725111564027070269710579156377653900210050677360692873548856950717077735724971492275722465522175892883197573916804276397143284954594245180776141869860033925480138858143033802945465036705957639063440190950861284456594945244826689811470380537909",10);
RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulus,privateExponent);
PrivateKey privateKey = keyFactory.generatePrivate(rsaPrivateKeySpec);
cipher.init(Cipher.DECRYPT_MODE,privateKey);
byte[] decryptData = cipher.doFinal(encryptData);
println("decryptData:" + new String(decryptData));
```
另外需要注意的一点是Cipher这个实例是有状态的，所以不是线程安全的
　　
### DSA（Digital Signature Algorithm）
 (DSA)是Schnorr和ElGamal签名算法的变种，被美国NIST作为DSS(DigitalSignature Standard)。

 DSA 一般用于数字签名和认证。在DSA数字签名和认证中，发送者使用自己的私钥对文件或消息进行签名，接受者收到消息后使用发送者的公钥来验证签名的真实性。DSA只是一种算法，和RSA不同之处在于它不能用作加密和解密，也不能进行密钥交换，只用于签名,它比RSA要快很多.
 
DSA是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。

### ECC
椭圆加密算法（ECC）是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。与主流的RSA算法相比，ECC算法可以使用较短的密钥达到相同的安全程度。近年来，人们对ECC的认识已经不再处于研究阶段，开始逐步进入实际应用，如国家密码管理局颁布的SM2算法就是基于ECC算法的。


ECC的主要优势是在某些情况下它比其他的方法使用更小的密钥——比如RSA加密算法——提供相当的或更高等级的安全。ECC的另一个优势是可以定义群之间的双线性映射，基于Weil对或是Tate对；双线性映射已经在密码学中发现了大量的应用，例如基于身份的加密。不过一个缺点是加密和解密操作的实现比其他机制花费的时间长。

##### 原理：https://www.chinassl.net/ecc/n641.html
https://www.pediy.com/kssd/pediy06/pediy6014.htm

与RSA算法对比：
第六届国际密码学会议对应用于公钥密码系统的加密算法推荐了两种：基于大整数因子分解问题（IFP）的RSA算法和基于椭圆曲线上离散对数计算问题（ECDLP）的ECC算法。RSA算法的特点之一是数学原理简单、在工程应用中比较易于实现，但它的单位安全强度相对较低。目前用国际上公认的对于RSA算法最有效的攻击方法--一般数域筛(NFS)方法去破译和攻击RSA算法，它的破译或求解难度是亚指数级的。ECC算法的数学理论非常深奥和复杂，在工程应用中比较难于实现，但它的单位安全强度相对较高。用国际上公认的对于ECC算法最有效的攻击方法--Pollard rho方法去破译和攻击ECC算法，它的破译或求解难度基本上是指数级的。正是由于RSA算法和ECC算法这一明显不同，使得ECC算法的单位安全强度高于RSA算法，也就是说，要达到同样的安全强度，ECC算法所需的密钥长度远比RSA算法低。这就有效地解决了为了提高安全强度必须增加密钥长度所带来的工程实现难度的问题。

ECC 与 RSA 相比，有以下的优点：
（1）相同密钥长度下，安全性能更高，如160位ECC已经与1024位RSA、DSA有相同的安全强度。
（2）计算量小，处理速度快，在私钥的处理速度上（解密和签名），ECC远 比RSA、DSA快得多。
（3）存储空间占用小 ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多， 所以占用的存储空间小得多。
（4）带宽要求低使得ECC具有广泛得应用前景。



## 数字签名
所谓数字签名就是附加在数据单元上的一些数据,或是对数据单元所作的密码变换。这种数据或变换允许数据单元的接收者用以确认数据单元的来源和数据单元的完整性并保护数据,防止被人(例如接收者)进行伪造。

- 普通数字签名算法有RSA、ElGamal、Fiat-Shamir、Guillou- Quisquarter、Schnorr、Ong-Schnorr-Shamir数字签名算法、Des/DSA,椭圆曲线数字签名算法和有限自动机数字签名算法等。
- 特殊数字签名有盲签名、代理签名、群签名、不可否认签名、公平盲签名、门限签名、具有消息恢复功能的签名等,

数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。

数字签名是个加密的过程，数字签名验证是个解密的过程。

数字签名有两种功效：一是能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。二是数字签名能确定消息的完整性。因为数字签名的特点是它代表了文件的特征，文件如果发生改变，数字摘要的值也将发生变化。不同的文件将得到不同的数字摘要。 一次数字签名涉及到一个哈希函数、发送者的公钥、发送者的私钥。”

## 数字证书
数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息以及公开密钥的文件。最简单的证书包含一个公开密钥、名称以及证书授权中心的数字签名。数字证书还有一个重要的特征就是只在特定的时间段内有效。
数字证书是一种权威性的电子文档，可以由权威公正的第三方机构，即CA（例如中国各地方的CA公司）中心签发的证书，也可以由企业级CA系统进行签发。


#### 证书格式
##### X509

openssl的x509命令简单入门：https://blog.csdn.net/u010846177/article/details/54356897

所有的X.509证书包含以下数据：
1. X.509版本号：指出该证书使用了哪种版本的X.509标准，版本号会影响证书中的一些特定信息。目前的版本是3。
2. 证书持有人的公钥：包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数。
3. 证书的序列号：由CA给予每一个证书分配的唯一的数字型编号，当证书被取消时，实际上是将此证书序列号放入由CA签发的CRL（Certificate Revocation List证书作废表，或证书黑名单表）中。这也是序列号唯一的原因。
4. 主题信息：证书持有人唯一的标识符(或称DN-distinguished name)这个名字在 Internet上应该是唯一的。DN由许多部分组成，看起来象这样：
CN=Bob Allen, OU=Total Network Security Division
O=Network Associates, Inc.
C=US
这些信息指出该科目的通用名、组织单位、组织和国家或者证书持有人的姓名、服务处所等信息。
5. 证书的有效期：证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效。
6. 认证机构：证书发布者，是签发该证书的实体唯一的CA的X.509名字。使用该证书意味着信任签发证书的实体。(注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书)
7. 发布者的数字签名：这是使用发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过。
8. 签名算法标识符：用来指定CA签署证书时所使用的签名算法。算法标识符用来指定CA签发证书时所使用的公开密钥算法和HASH算法。
